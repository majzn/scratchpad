<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SDF Bevel Generator (GPU, Enhanced Lighting)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800;700&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .canvas-container { 
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.2); 
            transition: all 0.3s ease;
        }
        .control-label { 
            font-weight: 600; 
            color: #374151; 
            font-size: 0.85rem; 
            margin-bottom: 2px;
        }
        .control-group { margin-bottom: 0.75rem; }
        
        input[type="range"] { height: 6px; }
        input[type="range"]::-webkit-slider-thumb { width: 14px; height: 14px; }
        
        input[type="color"] { height: 32px; }
        select { padding: 6px; }

        .control-grid { 
            display: grid; 
            grid-template-columns: repeat(2, 1fr); 
            gap: 12px; 
        }
        
        /* The canvas itself should not have a background color, as the shader handles the color/transparency */
        #sdfCanvas {
            background-color: transparent;
        }

        @media (max-width: 1024px) {
            #canvas-wrapper {
                width: 100% !important;
                height: auto !important;
            }
            #sdfCanvas {
                width: 100% !important;
                height: 100% !important;
                max-width: 512px;
                max-height: 512px;
            }
            .control-grid {
                grid-template-columns: 1fr;
                gap: 8px;
            }
        }
    </style>
</head>
<body class="p-4 sm:p-6">

    <div class="max-w-7xl mx-auto">
        <h1 class="text-3xl font-extrabold mb-1 text-gray-800">Spartan SDF Bevel Generator</h1>
        <p class="text-gray-600 mb-6 text-sm">Real-time GPU rendering with noise displacement and custom profiles.</p>

        <div class="flex flex-col lg:flex-row gap-6">

            <div class="lg:w-1/3 bg-white p-4 rounded-xl shadow-xl h-full order-2 lg:order-1">
                <h2 class="text-xl font-bold mb-4 text-indigo-700">Parameters</h2>
                
                <div id="controls" class="control-grid">
                    
                    <div class="control-group">
                        <label for="shapeType" class="control-label block">Shape</label>
                        <select id="shapeType">
                            <option value="0">Rounded Box</option>
                            <option value="1">Circle</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label for="bevelMode" class="control-label block">Bevel Mode</label>
                        <select id="bevelMode">
                            <option value="1">Raised (Outer)</option>
                            <option value="-1">Pressed (Inner)</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label for="bevelShape" class="control-label block">Bevel Profile</label>
                        <select id="bevelShape">
                            <option value="0">Linear</option>
                            <option value="1">Smoothstep</option>
                            <option value="2">Inverse Linear</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label for="frameWidth" class="control-label block">Thickness: <span id="frameWidthValue" class="font-normal text-xs text-gray-500">20</span> px</label>
                        <input type="range" id="frameWidth" min="10" max="150" value="20" class="w-full">
                    </div>

                    <div class="control-group">
                        <label for="outerCornerRadius" class="control-label block">Outer Radius: <span id="outerCornerRadiusValue" class="font-normal text-xs text-gray-500">30</span> px</label>
                        <input type="range" id="outerCornerRadius" min="0" max="150" value="30" class="w-full">
                    </div>

                    <div class="control-group">
                        <label for="innerCornerRadius" class="control-label block">Inner Radius: <span id="innerCornerRadiusValue" class="font-normal text-xs text-gray-500">20</span> px</label>
                        <input type="range" id="innerCornerRadius" min="0" max="150" value="20" class="w-full">
                    </div>
                    
                    <div class="control-group">
                        <label for="bevelStrength" class="control-label block">Depth (Z): <span id="bevelStrengthValue" class="font-normal text-xs text-gray-500">10</span></label>
                        <input type="range" id="bevelStrength" min="1" max="100" value="10" class="w-full">
                    </div>

                    <div class="control-group">
                        <label for="plateauWidth" class="control-label block">Plateau Width (%): <span id="plateauWidthValue" class="font-normal text-xs text-gray-500">0</span></label>
                        <input type="range" id="plateauWidth" min="0" max="100" value="0" class="w-full">
                    </div>

                    <div class="control-group">
                        <label for="plateauSmoothness" class="control-label block">Plateau Curve Smoothness: <span id="plateauSmoothnessValue" class="font-normal text-xs text-gray-500">0.0</span></label>
                        <input type="range" id="plateauSmoothness" min="0.0" max="1.0" step="0.05" value="0.0" class="w-full">
                    </div>

                    <div class="control-group">
                        <label for="bevelSoftness" class="control-label block">Softness (Neumorphic): <span id="bevelSoftnessValue" class="font-normal text-xs text-gray-500">0.05</span></label>
                        <input type="range" id="bevelSoftness" min="0.01" max="0.5" step="0.01" value="0.05" class="w-full">
                    </div>

                    <div class="col-span-2 text-sm font-semibold text-gray-700 mt-2 border-t pt-3">Enhanced Lighting (Blinn-Phong + Fresnel)</div>
                    
                    <div class="control-group">
                        <label for="lightAngle" class="control-label block">Light XY Angle (Azimuth): <span id="lightAngleValue" class="font-normal text-xs text-gray-500">45</span> deg</label>
                        <input type="range" id="lightAngle" min="0" max="360" value="45" class="w-full">
                    </div>
                    
                    <div class="control-group">
                        <label for="lightAltitude" class="control-label block">Light Z Angle (Altitude): <span id="lightAltitudeValue" class="font-normal text-xs text-gray-500">45</span> deg</label>
                        <input type="range" id="lightAltitude" min="1" max="90" value="45" class="w-full">
                    </div>
                    
                    <div class="control-group">
                        <label for="ambientLight" class="control-label block">Ambient Light: <span id="ambientLightValue" class="font-normal text-xs text-gray-500">0.3</span></label>
                        <input type="range" id="ambientLight" min="0.0" max="1.0" step="0.01" value="0.3" class="w-full">
                    </div>

                    <div class="control-group">
                        <label for="diffuseStrength" class="control-label block">Diffuse Strength: <span id="diffuseStrengthValue" class="font-normal text-xs text-gray-500">1.0</span></label>
                        <input type="range" id="diffuseStrength" min="0.0" max="2.0" step="0.01" value="1.0" class="w-full">
                    </div>
                    
                    <div class="control-group">
                        <label for="shininess" class="control-label block">Shininess (Power): <span id="shininessValue" class="font-normal text-xs text-gray-500">20</span></label>
                        <input type="range" id="shininess" min="1" max="200" value="20" class="w-full">
                    </div>

                    <div class="control-group">
                        <label for="specularIntensity" class="control-label block">Specular/Reflectivity: <span id="specularIntensityValue" class="font-normal text-xs text-gray-500">0.5</span></label>
                        <input type="range" id="specularIntensity" min="0.0" max="1.0" step="0.01" value="0.5" class="w-full">
                    </div>
                    
                    <div class="col-span-2 text-sm font-semibold text-gray-700 mt-2 border-t pt-3">Noise Displacement</div>
                    
                    <div class="control-group">
                        <label for="noiseAmplitude" class="control-label block">Amplitude: <span id="noiseAmplitudeValue" class="font-normal text-xs text-gray-500">0</span></label>
                        <input type="range" id="noiseAmplitude" min="0" max="50" value="0" class="w-full">
                    </div>
                    
                    <div class="control-group">
                        <label for="noiseFrequency" class="control-label block">Frequency: <span id="noiseFrequencyValue" class="font-normal text-xs text-gray-500">0.01</span></label>
                        <input type="range" id="noiseFrequency" min="0.001" max="0.1" step="0.001" value="0.01" class="w-full">
                    </div>

                    <div class="control-group">
                        <label for="noiseSpeed" class="control-label block">Speed: <span id="noiseSpeedValue" class="font-normal text-xs text-gray-500">0</span></label>
                        <input type="range" id="noiseSpeed" min="0" max="50" value="0" class="w-full">
                    </div>
                    
                    <div class="control-group">
                        <label for="padding" class="control-label block">Padding: <span id="paddingValue" class="font-normal text-xs text-gray-500">10</span> px</label>
                        <input type="range" id="padding" min="0" max="100" value="10" class="w-full">
                    </div>

                    <div class="col-span-2 text-sm font-semibold text-gray-700 mt-2 border-t pt-3">Colors & Output</div>

                    <div class="control-group">
                        <label for="primaryColor" class="control-label block">Frame Base Color</label>
                        <input type="color" id="primaryColor" value="#4f46e5" class="h-8">
                    </div>
                    
                    <div class="control-group">
                        <label for="bgColor" class="control-label block">Inside/Outside Color</label>
                        <input type="color" id="bgColor" value="#e5e7eb" class="h-8">
                    </div>
                    
                    <div class="control-group">
                        <label for="highlightColor" class="control-label block">Highlight/Specular</label>
                        <input type="color" id="highlightColor" value="#ffffff" class="h-8">
                    </div>
                    
                    <div class="control-group">
                        <label for="shadowColor" class="control-label block">Shadow/Dim</label>
                        <input type="color" id="shadowColor" value="#2d3748" class="h-8">
                    </div>

                    <div class="control-group col-span-2">
                        <label for="canvasSize" class="control-label block">Resolution: <span id="canvasSizeValue" class="font-normal text-xs text-gray-500">512</span> x 512 px</label>
                        <input type="range" id="canvasSize" min="256" max="1024" step="256" value="512" class="w-full">
                    </div>
                </div>

                <button id="generatePng" class="mt-4 w-full bg-green-500 hover:bg-green-600 text-white font-semibold py-2 rounded-lg transition-colors shadow-lg focus:outline-none focus:ring-4 focus:ring-green-500/50">
                    Download PNG (Transparent)
                </button>
                <p id="statusMessage" class="mt-2 text-center text-sm text-gray-700 h-5"></p>
            </div>

            <div class="lg:w-2/3 flex justify-center items-center order-1 lg:order-2">
                <div id="canvas-wrapper" class="canvas-container bg-white rounded-xl overflow-hidden p-4 flex justify-center items-center">
                    <canvas id="sdfCanvas" width="512" height="512" class="rounded-lg shadow-inner"></canvas>
                </div>
            </div>
            
        </div>
    </div>

    <script id="vs" type="x-shader/x-vertex">
        attribute vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    </script>

    <script id="fs" type="x-shader/x-fragment">
        precision highp float;

        uniform vec2 u_resolution;
        uniform float u_time;
        uniform float u_frameWidth;
        uniform float u_outerRadius;
        uniform float u_innerRadius;
        uniform float u_bevelStrength;
        uniform float u_lightAngle;
        uniform float u_lightAltitude;
        uniform float u_specularIntensity; 
        uniform float u_bevelMode; 
        uniform float u_bevelShape; 
        uniform float u_bevelSoftness;
        uniform float u_noiseAmplitude;
        uniform float u_noiseFrequency;
        uniform float u_noiseSpeed;
        uniform float u_padding;
        uniform float u_shapeType; 
        uniform float u_ambientLight; 
        uniform float u_diffuseStrength; 
        uniform float u_shininess; 
        uniform float u_plateauWidth;
        uniform float u_plateauSmoothness; 
        uniform float u_exportMode;

        uniform vec3 u_primaryColor;
        uniform vec3 u_highlightColor;
        uniform vec3 u_shadowColor;
        uniform vec3 u_bgColor;

        const float L_Z_STRENGTH = 1.0; 
        const float EPSILON = 1.0; 
        const float PI = 3.14159265359;

        // --- Utility Functions ---

        float hash(vec2 p) {
            p = fract(p * 0.3183099 + vec2(0.1));
            p *= 17.0;
            return fract(p.x * p.y * (p.x + p.y));
        }

        float noise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            vec2 u = f*f*(3.0-2.0*f); 
            
            float a = hash(i);
            float b = hash(i + vec2(1.0, 0.0));
            float c = hash(i + vec2(0.0, 1.0));
            float d = hash(i + vec2(1.0, 1.0));
            
            return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
        }

        // --- SDF Primitives ---
        
        float sdfRoundedBox(vec2 p, vec2 size, float radius) {
            vec2 d = abs(p) - size;
            return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
        }

        float sdfCircle(vec2 p, float radius) {
            return length(p) - radius;
        }

        float map(vec2 p, vec2 boxHalfSize, float radius, float shapeType) {
            if (shapeType == 0.0) { 
                return sdfRoundedBox(p, boxHalfSize, radius);
            } else { 
                float r = boxHalfSize.x + radius; 
                return sdfCircle(p, r);
            }
        }
        
        // Utility to get the 2D position displacement vector (noise applied along the 2D normal)
        vec2 get_displacement_vector(vec2 p, vec2 boxHalfSizeCenter, float centerRadius) {
            if (u_noiseAmplitude <= 0.0) return vec2(0.0);
            
            // Calculate 2D normal direction based on the core shape at P
            // Uses its own small epsilon to determine the boundary direction
            vec2 normal_dir = normalize(vec2(
                 map(p + vec2(EPSILON, 0.0), boxHalfSizeCenter, centerRadius, u_shapeType) - map(p - vec2(EPSILON, 0.0), boxHalfSizeCenter, centerRadius, u_shapeType),
                 map(p + vec2(0.0, EPSILON), boxHalfSizeCenter, centerRadius, u_shapeType) - map(p - vec2(0.0, EPSILON), boxHalfSizeCenter, centerRadius, u_shapeType)
            ));
            
            // Calculate noise value
            float noiseVal = noise(p * u_noiseFrequency + u_time * u_noiseSpeed) * 2.0 - 1.0;
            
            return normal_dir * noiseVal * u_noiseAmplitude;
        }


        // --- Height Profile Logic (Refactored) ---

        // Calculates the height factor (t_ridge, 0.0 to 1.0) based on 2D position
        float get_height_factor(vec2 p, float W_max, vec2 boxHalfSizeCenter, float centerRadius) {
            // 1. Apply displacement to the sample point p
            // NOTE: This displacement is internal to the height calculation for the normal map generation.
            vec2 displacement = get_displacement_vector(p, boxHalfSizeCenter, centerRadius);
            vec2 displaced_p = p + displacement;
            
            // 2. Calculate distance field using the displaced position
            float d_center = map(displaced_p, boxHalfSizeCenter, centerRadius, u_shapeType);
            float D_abs = abs(d_center); 

            float plateau_fraction = clamp(u_plateauWidth / 100.0, 0.0, 0.99);
            float W_plateau_half = W_max * plateau_fraction;

            float t_ridge;

            if (D_abs <= W_plateau_half) {
                t_ridge = 1.0;
            } else {
                float W_slope = W_max - W_plateau_half;
                
                if (W_slope < 0.001) { 
                    t_ridge = 1.0;
                } else {
                    float t_slope_raw = (D_abs - W_plateau_half) / W_slope;
                    
                    float smoothed_t_slope_raw = mix(t_slope_raw, smoothstep(0.0, 1.0, t_slope_raw), u_plateauSmoothness);

                    if (u_bevelShape == 1.0) { 
                        t_ridge = 1.0 - smoothstep(0.0, 1.0, smoothed_t_slope_raw);
                    } else if (u_bevelShape == 2.0) { 
                        t_ridge = 1.0 - smoothed_t_slope_raw * smoothed_t_slope_raw;
                    } else { 
                        t_ridge = 1.0 - smoothed_t_slope_raw;
                    }
                }
            }
            return t_ridge;
        }
        
        // --- Correct Normal Calculation (Finite Differences) ---
        
        // Calculates the 3D Normal using the numerical gradient of the height field H(p)
        vec3 calculateNormal3D(vec2 p, float W_max, vec2 boxHalfSizeCenter, float centerRadius) {
            const float H_EPSILON = 1.0; // Epsilon for numerical gradient calculation (in pixels)
            
            // Total Z height scale factor (Height = t_ridge * Z_SCALE)
            float Z_SCALE = W_max * (u_bevelStrength / 50.0) * u_bevelMode * L_Z_STRENGTH; 

            // Calculate height factor at small offsets
            float h_x1 = get_height_factor(p + vec2(H_EPSILON, 0.0), W_max, boxHalfSizeCenter, centerRadius);
            float h_x2 = get_height_factor(p - vec2(H_EPSILON, 0.0), W_max, boxHalfSizeCenter, centerRadius);
            float h_y1 = get_height_factor(p + vec2(0.0, H_EPSILON), W_max, boxHalfSizeCenter, centerRadius);
            float h_y2 = get_height_factor(p - vec2(0.0, H_EPSILON), W_max, boxHalfSizeCenter, centerRadius);

            // Calculate gradient (slope) component: dH/dx and dH/dy
            // The gradient is negative because the surface is defined as z = H(x,y)
            vec3 n = normalize(vec3(
                -(h_x1 - h_x2) / (2.0 * H_EPSILON) * Z_SCALE,
                -(h_y1 - h_y2) / (2.0 * H_EPSILON) * Z_SCALE,
                1.0
            ));
            
            return n;
        }

        // --- Main Fragment Shader ---

        void main() {
            vec2 p_screen = gl_FragCoord.xy;
            vec2 p = p_screen - u_resolution * 0.5; 
            
            float max_extent = u_resolution.x * 0.5 - u_padding;

            float outerRadius = u_outerRadius;
            float innerRadius = u_innerRadius;
            
            float W_max = u_frameWidth * 0.5; // Half width of the bevel area

            float outerStraight = max(max_extent - outerRadius, 0.0);
            float innerStraight = max(outerStraight - u_frameWidth, 0.0);
            float centerRadius = max(outerRadius - W_max, 0.0);
            float centerStraight = max(outerStraight - W_max, 0.0);
            
            vec2 boxHalfSizeOuter = vec2(outerStraight);
            vec2 boxHalfSizeInner = vec2(innerStraight);
            vec2 boxHalfSizeCenter = vec2(centerStraight);

            // --- 1. Calculate Displacement and Displaced Position (for boundary check) ---
            vec2 displacement = get_displacement_vector(p, boxHalfSizeCenter, centerRadius);
            vec2 p_displaced_for_boundary = p + displacement;

            // --- 2. Calculate base distances using the DISPLACED position ---
            float outerDist = map(p_displaced_for_boundary, boxHalfSizeOuter, outerRadius, u_shapeType);
            float innerDist = map(p_displaced_for_boundary, boxHalfSizeInner, innerRadius, u_shapeType);
            
            vec4 final_output_color;

            // Check if fragment is within the displaced frame bounds
            if (outerDist < 0.0 && innerDist > 0.0) {
                
                // --- 3. Correct 3D Normal Calculation (using ORIGINAL p) ---
                // The normal calculation (via get_height_factor) already applies the height-based displacement internally.
                vec3 normal = calculateNormal3D(p, W_max, boxHalfSizeCenter, centerRadius); 
                
                // --- Light Direction (using Altitude and Azimuth) ---
                float lightAngleRad = u_lightAngle * (PI / 180.0);
                float lightAltitudeRad = u_lightAltitude * (PI / 180.0);
                
                float L_altitude_cos = cos(lightAltitudeRad);
                float L_altitude_sin = sin(lightAltitudeRad);

                float L_x = cos(lightAngleRad) * L_altitude_cos;
                float L_y = sin(lightAngleRad) * L_altitude_cos;
                float L_z = L_altitude_sin;
                
                vec3 lightDir = normalize(vec3(L_x, L_y, L_z));
                vec3 viewDir = vec3(0.0, 0.0, 1.0); // View is straight down onto the surface (Z-axis)
                
                // --- Blinn-Phong Lighting Model ---
                vec3 ambient = u_primaryColor * u_ambientLight;
                
                // Diffuse
                float NdotL_diffuse = max(dot(normal, lightDir), 0.0);
                vec3 diffuse = u_primaryColor * NdotL_diffuse * u_diffuseStrength;
                
                // Specular
                vec3 halfVector = normalize(lightDir + viewDir);
                float NdotH = max(dot(normal, halfVector), 0.0);
                float specularFactor = pow(NdotH, u_shininess);
                vec3 specular = u_highlightColor * specularFactor * u_specularIntensity; 
                
                // --- Simplified Fresnel Reflection ---
                const float F0 = 0.04; 
                float cosTheta = max(0.0, dot(normal, viewDir));
                float fresnel = F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
                vec3 reflection = u_highlightColor * fresnel * u_specularIntensity * 5.0; 
                
                // Final Lit Color
                vec3 lit_color = ambient + diffuse + specular + reflection;

                // --- Softness/Neumorphic Mix ---
                float raw_NdotL = dot(normal, lightDir);
                float shaded_dot = raw_NdotL * u_bevelMode; 

                float light_mix_factor = smoothstep(-u_bevelSoftness, u_bevelSoftness, shaded_dot); 

                vec3 shadow_tinted_color = mix(u_shadowColor, u_primaryColor * 0.8, u_diffuseStrength * 0.5);
                
                vec3 output_color = mix(shadow_tinted_color, lit_color, light_mix_factor);

                final_output_color = vec4(output_color, 1.0);
                
            } else { 
                // Outside the displaced bevel
                if (u_exportMode < 0.5) {
                    final_output_color = vec4(u_bgColor, 1.0);
                } else {
                    final_output_color = vec4(0.0, 0.0, 0.0, 0.0);
                }
            }
            gl_FragColor = final_output_color;
        }
    </script>
    
    <script>
        (function() {
            function hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? [
                    parseInt(result[1], 16) / 255.0,
                    parseInt(result[2], 16) / 255.0,
                    parseInt(result[3], 16) / 255.0
                ] : [0, 0, 0];
            }

            const canvas = document.getElementById('sdfCanvas');
            const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true, alpha: true }); 
            let rafId = null;
            let program;
            let uLocations = {};
            let startTime = performance.now();
            let currentExportMode = 0.0;

            const statusMessage = document.getElementById('statusMessage');

            if (!gl) {
                statusMessage.textContent = 'WebGL is not supported. Cannot render.';
                return;
            }

            function compileShader(source, type) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compile error: ' + gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null; 
                }
                return shader;
            }

            function initWebGL() {
                const vsSource = document.getElementById('vs').textContent;
                const fsSource = document.getElementById('fs').textContent;

                const vertexShader = compileShader(vsSource, gl.VERTEX_SHADER);
                const fragmentShader = compileShader(fsSource, gl.FRAGMENT_SHADER);
                
                if (!vertexShader || !fragmentShader) {
                    program = null;
                    return;
                }

                program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);

                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Program link error: ' + gl.getProgramInfoLog(program));
                    program = null; 
                    return;
                }

                gl.useProgram(program);

                const positionAttributeLocation = gl.getAttribLocation(program, 'position');
                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                const positions = new Float32Array([
                    -1, -1, 1, -1, -1, 1,
                    -1, 1, 1, -1, 1, 1,
                ]);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(positionAttributeLocation);
                gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
                
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            }

            function getUniformLocations() {
                if (!program) return;

                const uniforms = [
                    'u_resolution', 'u_time', 'u_frameWidth', 'u_outerRadius', 'u_innerRadius',
                    'u_bevelStrength', 'u_lightAngle', 'u_lightAltitude', 'u_specularIntensity', 'u_bevelMode',
                    'u_bevelShape', 'u_bevelSoftness', 'u_noiseAmplitude', 'u_noiseFrequency',
                    'u_noiseSpeed', 'u_padding', 'u_shapeType',
                    'u_ambientLight', 'u_diffuseStrength', 'u_shininess', 
                    'u_primaryColor', 'u_highlightColor', 'u_shadowColor', 'u_bgColor',
                    'u_plateauWidth',
                    'u_plateauSmoothness', 
                    'u_exportMode'
                ];
                uniforms.forEach(name => {
                    uLocations[name] = gl.getUniformLocation(program, name);
                });
            }

            function getControls() {
                const C = {
                    frameWidth: parseFloat(document.getElementById('frameWidth').value),
                    outerCornerRadius: parseFloat(document.getElementById('outerCornerRadius').value),
                    innerCornerRadius: parseFloat(document.getElementById('innerCornerRadius').value),
                    bevelStrength: parseFloat(document.getElementById('bevelStrength').value),
                    plateauWidth: parseFloat(document.getElementById('plateauWidth').value),
                    plateauSmoothness: parseFloat(document.getElementById('plateauSmoothness').value),
                    lightAngle: parseFloat(document.getElementById('lightAngle').value),
                    lightAltitude: parseFloat(document.getElementById('lightAltitude').value),
                    specularIntensity: parseFloat(document.getElementById('specularIntensity').value),
                    ambientLight: parseFloat(document.getElementById('ambientLight').value), 
                    diffuseStrength: parseFloat(document.getElementById('diffuseStrength').value), 
                    shininess: parseFloat(document.getElementById('shininess').value), 
                    canvasSize: parseInt(document.getElementById('canvasSize').value),
                    bevelMode: parseFloat(document.getElementById('bevelMode').value),
                    bevelShape: parseFloat(document.getElementById('bevelShape').value),
                    bevelSoftness: parseFloat(document.getElementById('bevelSoftness').value),
                    noiseAmplitude: parseFloat(document.getElementById('noiseAmplitude').value),
                    noiseFrequency: parseFloat(document.getElementById('noiseFrequency').value),
                    noiseSpeed: parseFloat(document.getElementById('noiseSpeed').value),
                    padding: parseFloat(document.getElementById('padding').value),
                    shapeType: parseFloat(document.getElementById('shapeType').value),
                    primaryRgb: hexToRgb(document.getElementById('primaryColor').value),
                    highlightRgb: hexToRgb(document.getElementById('highlightColor').value),
                    shadowRgb: hexToRgb(document.getElementById('shadowColor').value),
                    bgRgb: hexToRgb(document.getElementById('bgColor').value),
                };
                
                document.getElementById('frameWidthValue').textContent = C.frameWidth;
                document.getElementById('outerCornerRadiusValue').textContent = C.outerCornerRadius;
                document.getElementById('innerCornerRadiusValue').textContent = C.innerCornerRadius;
                document.getElementById('bevelStrengthValue').textContent = C.bevelStrength;
                document.getElementById('plateauWidthValue').textContent = C.plateauWidth;
                document.getElementById('plateauSmoothnessValue').textContent = C.plateauSmoothness.toFixed(1);
                document.getElementById('lightAngleValue').textContent = C.lightAngle;
                document.getElementById('lightAltitudeValue').textContent = C.lightAltitude;
                document.getElementById('specularIntensityValue').textContent = C.specularIntensity.toFixed(2);
                document.getElementById('ambientLightValue').textContent = C.ambientLight.toFixed(2); 
                document.getElementById('diffuseStrengthValue').textContent = C.diffuseStrength.toFixed(1); 
                document.getElementById('shininessValue').textContent = C.shininess; 
                document.getElementById('canvasSizeValue').textContent = C.canvasSize;
                document.getElementById('bevelSoftnessValue').textContent = C.bevelSoftness.toFixed(2);
                document.getElementById('noiseAmplitudeValue').textContent = C.noiseAmplitude;
                document.getElementById('noiseFrequencyValue').textContent = C.noiseFrequency.toFixed(3);
                document.getElementById('noiseSpeedValue').textContent = C.noiseSpeed;
                document.getElementById('paddingValue').textContent = C.padding;

                return C;
            }

            function resizeCanvas(newSize) {
                if (canvas.width === newSize) return;
                
                canvas.width = newSize;
                canvas.height = newSize;
                gl.viewport(0, 0, newSize, newSize);
                
                const wrapper = document.getElementById('canvas-wrapper');
                wrapper.style.width = `${newSize + 32}px`; 
                wrapper.style.height = `${newSize + 32}px`; 
            }

            function render(currentTime = 0) {
                if (!program) return;
                
                const C = getControls();
                resizeCanvas(C.canvasSize);
                
                gl.clearColor(0.0, 0.0, 0.0, 0.0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                const t = (currentTime - startTime) / 1000.0;
                
                gl.uniform2f(uLocations.u_resolution, C.canvasSize, C.canvasSize);
                gl.uniform1f(uLocations.u_time, t);
                gl.uniform1f(uLocations.u_frameWidth, C.frameWidth);
                gl.uniform1f(uLocations.u_outerRadius, C.outerCornerRadius);
                gl.uniform1f(uLocations.u_innerRadius, C.innerCornerRadius);
                gl.uniform1f(uLocations.u_bevelStrength, C.bevelStrength);
                gl.uniform1f(uLocations.u_plateauWidth, C.plateauWidth);
                gl.uniform1f(uLocations.u_plateauSmoothness, C.plateauSmoothness);
                gl.uniform1f(uLocations.u_lightAngle, C.lightAngle); 
                gl.uniform1f(uLocations.u_lightAltitude, C.lightAltitude);
                gl.uniform1f(uLocations.u_specularIntensity, C.specularIntensity);
                gl.uniform1f(uLocations.u_bevelMode, C.bevelMode);
                gl.uniform1f(uLocations.u_bevelShape, C.bevelShape);
                gl.uniform1f(uLocations.u_bevelSoftness, C.bevelSoftness);
                gl.uniform1f(uLocations.u_noiseAmplitude, C.noiseAmplitude);
                gl.uniform1f(uLocations.u_noiseFrequency, C.noiseFrequency);
                gl.uniform1f(uLocations.u_noiseSpeed, C.noiseSpeed);
                gl.uniform1f(uLocations.u_padding, C.padding);
                gl.uniform1f(uLocations.u_shapeType, C.shapeType);
                
                gl.uniform1f(uLocations.u_ambientLight, C.ambientLight);
                gl.uniform1f(uLocations.u_diffuseStrength, C.diffuseStrength);
                gl.uniform1f(uLocations.u_shininess, C.shininess);

                gl.uniform3fv(uLocations.u_primaryColor, C.primaryRgb);
                gl.uniform3fv(uLocations.u_highlightColor, C.highlightRgb);
                gl.uniform3fv(uLocations.u_shadowColor, C.shadowRgb);
                gl.uniform3fv(uLocations.u_bgColor, C.bgRgb);
                
                gl.uniform1f(uLocations.u_exportMode, currentExportMode);

                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }

            function animate(timestamp) {
                if (!program) return;
                
                const C = getControls();

                if (C.noiseSpeed === 0 && rafId !== null) {
                    cancelAnimationFrame(rafId);
                    rafId = null;
                    render();
                    return;
                } 
                
                if (C.noiseSpeed > 0) {
                    render(timestamp);
                    rafId = requestAnimationFrame(animate);
                }
            }

            function setup() {
                initWebGL();
                getUniformLocations();
                if (program) {
                    render(performance.now());
                } else {
                    statusMessage.textContent = 'Error: Failed to initialize WebGL program.';
                }
            }

            document.getElementById('controls').addEventListener('input', () => {
                if (!program) return;

                if (getControls().noiseSpeed > 0 && rafId === null) {
                    animate(performance.now());
                } else {
                    render(performance.now());
                }
            });
            
            document.getElementById('generatePng').addEventListener('click', () => {
                if (!program) {
                    statusMessage.textContent = 'Cannot download: WebGL program failed to initialize.';
                    return;
                }
                
                const currentSpeed = getControls().noiseSpeed;

                // 1. Enter export mode
                currentExportMode = 1.0;
                if (rafId) cancelAnimationFrame(rafId);
                render(performance.now());

                // 2. Download the PNG
                const dataURL = canvas.toDataURL('image/png');
                
                const link = document.createElement('a');
                link.href = dataURL;
                link.download = `sdf_bevel_transparent_${new Date().toISOString()}.png`;
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                statusMessage.textContent = 'PNG downloaded successfully (fully transparent)!';
                
                // 3. Exit export mode and restore animation if needed
                currentExportMode = 0.0;
                
                setTimeout(() => { 
                    render(performance.now()); // Restore preview frame
                    statusMessage.textContent = currentSpeed > 0 ? 'Animation running...' : ''; 
                }, 100);

                if (currentSpeed > 0) {
                    animate(performance.now());
                }
            });
            
            window.onload = () => {
                setup();
                if (program) {
                    statusMessage.textContent = 'Ready! GPU rendering active.';
                    setTimeout(() => statusMessage.textContent = '', 3000);
                }
            };
        })();
    </script>
</body>
</html>